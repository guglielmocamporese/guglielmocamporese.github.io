{% extends "./layout.html" %}

{% block head %}
	{{ super() }}
	<link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.3/styles/default.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.3/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
{% endblock head %}

{% block imports %}
	{{ super() }}
	<script type="text/x-mathjax-config">
	  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
	</script>
	<script type="text/javascript"
	  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
	</script>
	<!--
	<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js"></script>
	<script type="text/javascript" src="{{ base_dir }}{{ url_for('static', filename='fourier.js') }}"></script>
	-->
	<script async defer crossorigin="anonymous" src="https://connect.facebook.net/it_IT/sdk.js#xfbml=1&version=v11.0" nonce="s9lC437y"></script>
{% endblock imports %}

{% block body%}

<!--
<div class="two-cols-container">
	<div class="first-col">
		<img id="img-example-fourier" style="width: 500px" src="{{ base_dir }}{{ url_for('static', filename='img/guglielmo.jpg') }}" alt="">
	</div>
	<div id="p5-container" class="second-col"></div>
</div>
-->
<div class="fb-like" data-href="https://guglielmocamporese.github.io/static/extras/fourier.html" data-width="" data-layout="button_count" data-action="like" data-size="small" data-share="true" style="text-align: center"></div>


<div class="images-column">
	<div class="images-row">
		<figure>
			<img src="{{ base_dir }}{{ url_for('static', filename='img/fourier/1.gif') }}">
			<figcaption>$$N=1$$</figcaption>
		</figure>
		<figure>
			<img src="{{ base_dir }}{{ url_for('static', filename='img/fourier/2.gif') }}">
			<figcaption>$$N=2$$</figcaption>
		</figure>
		<figure>
			<img src="{{ base_dir }}{{ url_for('static', filename='img/fourier/5.gif') }}">
			<figcaption>$$N=5$$</figcaption>
		</figure>
	</div>

	<div class="images-row">
		<figure>
			<img src="{{ base_dir }}{{ url_for('static', filename='img/fourier/10.gif') }}">
			<figcaption>$$N=10$$</figcaption>
		</figure>
		<figure>
			<img src="{{ base_dir }}{{ url_for('static', filename='img/fourier/20.gif') }}">
			<figcaption>$$N=20$$</figcaption>
		</figure>
		<figure>
			<img src="{{ base_dir }}{{ url_for('static', filename='img/fourier/50.gif') }}">
			<figcaption>$$N=50$$</figcaption>
		</figure>
	</div>

	<div class="images-row">
		<figure>
			<img src="{{ base_dir }}{{ url_for('static', filename='img/fourier/100.gif') }}">
			<figcaption>$$N=100$$</figcaption>
		</figure>
		<figure>
			<img src="{{ base_dir }}{{ url_for('static', filename='img/fourier/200.gif') }}">
			<figcaption>$$N=200$$</figcaption>
		</figure>
		<figure>
			<img src="{{ base_dir }}{{ url_for('static', filename='img/fourier/500.gif') }}">
			<figcaption>$$N=500$$</figcaption>
		</figure>
	</div>


</div>

<p><a href="https://colab.research.google.com/drive/1aSUzcgn6jOW-P1trqaA-o_Ts-gQbJZYR?usp=sharing" target="_blank"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"></a></p>

<p style="text-align: justify">
In general a signal can be approximated by a <a href="https://en.wikipedia.org/wiki/Fourier_transform" target="_blank">Fourier Series</a>. In this blog I will represent the signal coming from the edges of the image containing my face using the Fourier representation.
Considering $t \in \mathcal{T} = [t_0, t_1] \subset \mathbb{R}$ be an input variable, $T = t_1 - t_0$ the length of the input domain, and $f(\cdot) : \mathcal{T} \rightarrow \mathbb{C}$ being the function that represents the edges signal in the 2D complex plane, the Fourier representation of the signal can be computed as:

<div class="formula">$$f_N(t) = \sum_{n=-N}^N c_n e^{i \frac{2 \pi n}{T} t} = \sum_{n=-N}^N c_n e^{i \theta_n t}\ \ \ \ \ (1)$$</div>

where the coefficients are: 

<div class="formula">$$c_n = \frac{1}{T}\int_\mathcal{T} f(t) e^{-i \theta_n t} dt \ \ \ \ \ (2).$$</div>
</p>

<p style="text-align: justify">
Here $N$ is the number of components used for the approximating the input signal, the larger this number, the better the approximation. $T$ is the length of the input domain of $x$,  $T = | \mathcal{T}| $.
</p>

<p style="text-align: justify">
Let's make an example by considering an image:


<pre class="line-numbers"><code class="language-python">
# Imports
import numpy as np
import matplotlib.pyplot as plt
from PIL import Image
from sklearn.cluster import KMeans
import cv2
import requests

# Load the image
url = 'https://guglielmocamporese.github.io/static/static/img/fourier/image.png'
image = np.array(Image.open(requests.get(url, stream=True).raw))
</code></pre>

<div class="image-container" style="max-width: 100%">
	<img style="max-width: 90%" src="{{ base_dir }}{{ url_for('static', filename='img/fourier/image.png') }}" alt="">
</div>
</p>


<p style="text-align: justify">
Now let's compute the edges of the image by low-pass filtering the image and using the <a href="https://en.wikipedia.org/wiki/Canny_edge_detector">Canny algorithm</a>, already implemented in <a href="https://docs.opencv.org/3.4/da/d22/tutorial_py_canny.html">OpenCV</a>. 
<pre class="line-numbers"><code class="language-python">
# Compute the edges
def get_edges(x):
  """Extract edges from an image"""
  x = cv2.GaussianBlur(x, (5, 5), 0)
  x = cv2.Canny(x, 10, 200)
  return x

edges = get_edges(image) 
</code></pre>

<div class="image-container" style="max-width: 100%">
	<img style="max-width: 90%" src="{{ base_dir }}{{ url_for('static', filename='img/fourier/edges.png') }}" alt="">
</div>
</p>

<p style="text-align: justify">
The next step is to reduce the number of points contained in the edges. To this end, I clustered these points reducing them from a number $\sim 13000$ to $n\_cluster=2000$ as follows: 

<pre class="line-numbers"><code class="language-python">
# Cluster the points of the edges
edges_pts = np.stack(np.where(edges), 1)
edges_pts[:, 0] = image.shape[0] - edges_pts[:, 0]
edges_pts = np.stack([edges_pts[:, 1], edges_pts[:, 0]], 1)

kmeans = KMeans(n_clusters=2000, random_state=0).fit(edges_pts)
edges_centers = kmeans.cluster_centers_
</code></pre>

<div class="image-container" style="max-width: 100%">
	<img style="max-width: 90%" src="{{ base_dir }}{{ url_for('static', filename='img/fourier/edges_clustered.png') }}" alt="">
</div>
The image above shows the cluster centers that fit the edges.
</p>

<p style="text-align: justify">
For now we have a set of points that builds up the edge signal, but this set is un-ordered since each point does not have the meaning of "neighbors". In the image below you can see this fact by connecting adjacent points in the set.
<div class="image-container" style="max-width: 100%">
	<img style="max-width: 90%" src="{{ base_dir }}{{ url_for('static', filename='img/fourier/edges_clustered_not_ordered.png') }}" alt="">
</div>
</p>

<p style="text-align: justify">
In order to solve the order issue, I designed a sorting algorithm that returns a set of ordered points using the euclidian distance. 
<pre class="line-numbers"><code class="language-python">
# Sort the points to make a smooth path
dist = lambda p0, p1: (((p0 - p1) ** 2).sum() ** 0.5)

def sort_points(points):
  ordered_pts = [points[0]]
  points = [p for p in points[1:]]
  while len(points) > 0:
    p0 = ordered_pts[-1]
    dist_01 = [dist(p0, p1) for p1 in points]
    i_min = np.argmin(dist_01)
    closest_pt = points[i_min]
    del points[i_min]
    ordered_pts += [closest_pt]
  return np.array(ordered_pts)

edges_centers_sorted = sort_points(edges_centers)
</code></pre>

<div class="image-container" style="max-width: 100%">
	<img style="max-width: 90%" src="{{ base_dir }}{{ url_for('static', filename='img/fourier/edges_clustered_ordered.png') }}" alt="">
</div>
The image above shows the same points of the previous image, but with sorted points.
</p>

<p style="text-align: justify">
The equation in (1) returns complex values whereas the edge signal that I'm intered in is a real 2D function. In this case the Fourier Series representation can be rewritten as: 

<div class="formula">$$
		\begin{split}
			f_N(t) &= \sum_{n=-N}^N c_n e^{i \theta_n t} \\
				&= \sum_{n=-N}^N \Big[ Re\{c_n\} cos(\theta_n t) - Im\{c_n\} sin(\theta_n t) \Big] + \\
				&\ \ \ \ + i \sum_{n=-N}^N \Big[ - Re\{ c_n \} sin(\theta_n t) + Im\{c_n\} cos(\theta_n t) \Big]
		\end{split}$$
</div>

where the coefficients are:

<div class="formula">
	$$
	Re\{c_n\} = \frac{1}{T} \int_\mathcal{T} \Big[ Re\{f(t)\} cos(\theta_n t) + Im\{f(t)\} sin(\theta_n t)\Big]dt
	$$
</div>
<div class="formula">
	$$
	Im\{c_n\} = \frac{1}{T} \int_\mathcal{T} \Big[ -Re\{f(t)\} sin(\theta_n t) + Im\{f(t)\} cos(\theta_n t)\Big]dt
	$$
</div>

In the following code snippet I approximated the integrals above in order to evaluate them:

<pre class="line-numbers"><code class="language-python">
def f_transform(f, N=100):
  y = np.zeros_like(f) # output signal of shape [num_points, 2]
  num_points = f.shape[0]
  t = np.linspace(0, 1, num_points)
  dt = np.abs(t[1] - t[0])
  f_real, f_imag = f[:, 0], f[:, 1]
  for n in range(- N, N + 1):
    theta_n = 2 * np.pi * n
    cos_n = np.cos(theta_n * t)
    sin_n = np.sin(theta_n * t)
    c_real_n = (f_real * cos_n + f_imag * sin_n).sum() * dt
    c_imag_n = (- f_real * sin_n + f_imag * cos_n).sum() * dt
    y_real = c_real_n * cos_n - c_imag_n * sin_n
    y_imag = c_real_n * sin_n + c_imag_n * cos_n
    y += np.stack([y_real, y_imag], 1)
  return y

y = f_transform(edges_centers_sorted, N=550)
</code></pre>

<div class="image-container" style="max-width: 100%">
	<img style="max-width: 100%" src="{{ base_dir }}{{ url_for('static', filename='img/fourier/fourier_approxiamtion.png') }}" alt="">
</div>
</p>

{% endblock body %}
